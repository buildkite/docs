# Controlling Concurrency

Some tasks need to be run with very strict concurrency rules to ensure they don’t collide with each other. Common examples for needing concurrency control are deployments, app releases and infrastructure tasks.

To help you control concurrency Buildkite provides two primitives: concurrency limits, and concurrency groups. These two primitives are related, but are not explicitly linked. (?)

<%= toc %>

## Concurrency Limits

Concurrency limits define the number of jobs created from a single step that are allowed to be running at any one time. These limits are set per-step and only apply to jobs that are created from that step. 

For example:

A concurrency limit of `1` ensures that no two jobs created from that step will run at the same time. This a couple of different scenarios:

A) Two builds are created from the same pipeline and are running in parallel. This means that in the pool of currently jobs, there are two that have been created from the same step. As a concurrency limit of 1 was set on the step, these jobs will not run at the same time, even if there are agents available to do so.

B) You want to run one step multiple times and are using the `parallelism` attribute to create 5 jobs from this step each time a build is created. These jobs access a shared resource, so you don't want them to run at the same time. As a concurrency limit of 1 was set on the step, these jobs will run one after each other, even if there are agents available to run them all in parallel.

Adding a concurrency limit to a step can happen either through Buildkite, or in your `pipeline.yml` file. Defining concurrency in a `pipeline.yml` file also requires the use of the `concurrency-group` attribute. See below for more information.

<section class="Docs__troubleshooting-note">
    <h1>I'm getting ___ error when my pipeline upload runs</h1>
    <p>This error is caused by a missing concurrency group label. If you set a concurrency limit in a pipeline.yml file, you must also set a group label.</p>
</section>

## Concurrency Groups

Concurrency groups are labels that can be used to group together Buildkite jobs when applying concurrency limits. When you add a group label to a step in a `pipeline.yml` file, it will become a concurrency group that is available organsiation wide. Although they're created on individual steps, they represent [concurrent access to shared resources] and can be used by other pipelines. 

The names of these groups should be unique, unless they're accessing a shared resource like a deployment target. For example, you want to ensure that order or volume sensitive operations like deploys or API access don't happen at the same time, and run in order that they were created.  

Concurrency groups guarantee that jobs will be run in the order that they were created in. 
- something about pipeline uploads creating jobs in a weird order
- inheriting the scheduledAt time of the build creation or the initial pipeline upload job 

- dynamic pipelines need to be treated carefully, the pipeline upload step should have a CG if there are steps inside it that also use CGs (like a deploy)

If you have multiple pipeline uploaders within a single pipeline that each contain steps which share a concurrency group for access to a shared resource: we don't know about the steps inside a pipeline upload until it's running and the jobs are created, so if there are steps that rely heavily on correct ordering, take advantage of our waiter or block steps so that you can be sure that it will run correctly each time.
 
Common examples for concurrency group values include:

* `our-payment-gateway/deployment`
* `terraform/update-state`
* `my-mobile-app/app-store-release`

<section class="Docs__note">
	<p>When you create a step using the Buildkite web interface, you can’t set a custom concurrency group label. A label will be automatically generated for you based on that step.</p>
</section>

## Example: Deploy Step

The following is an example [command step](/docs/agent/cli-pipeline#command-steps) that ensures deployments run one at a time:

```yaml
- command: 'deploy.sh'
  label: '\:rocket\: Deploy production'
  branches: 'master'
  agents:
    deploy: true
  concurrency: 1
  concurrency_group: 'our-payment-gateway/deploy'
```

If multiple builds are created with this step, each deployment job will be queued up and run one at a time in the order they were created.
